<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/standards/Arbitrable.js | @kleros/archon</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="A javascript library for Ethereum dispute resolution. Provides the ability to interface with Arbitrable and Arbitrator Ethereum smart contracts, as defined in ERC 792."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="@kleros/archon"><meta property="twitter:description" content="A javascript library for Ethereum dispute resolution. Provides the ability to interface with Arbitrable and Arbitrator Ethereum smart contracts, as defined in ERC 792."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Archon.js~Archon.html">Archon</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#constants">constants</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-CONTRACT_ERROR">CONTRACT_ERROR</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-ERROR_FETCHING_EVENTS">ERROR_FETCHING_EVENTS</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-HTTP_ERROR">HTTP_ERROR</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-MISSING_PARAMETERS">MISSING_PARAMETERS</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-PARAMETER_ERROR">PARAMETER_ERROR</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-VALIDATION_ERROR">VALIDATION_ERROR</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DisputeStatus">DisputeStatus</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-functions">functions</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#standards">standards</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/standards/Arbitrable.js~Arbitrable.html">Arbitrable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/standards/Arbitrator.js~Arbitrator.html">Arbitrator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/standards/StandardContract.js~StandardContract.html">StandardContract</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#utils">utils</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/EventListener.js~EventListener.html">EventListener</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-fetchDataFromScript">fetchDataFromScript</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-multihashFile">multihashFile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-validMultihash">validMultihash</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-validateFileFromURI">validateFileFromURI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isRequired">isRequired</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sanitizeMetaEvidence">sanitizeMetaEvidence</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getHttpUri">getHttpUri</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getURIProtocol">getURIProtocol</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getURISuffix">getURISuffix</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/standards/Arbitrable.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import ArbitrableJSONInterface from &quot;../abis/arbitrable&quot;;

import * as errorConstants from &quot;../constants/error&quot;;
import EventListener from &quot;../utils/EventListener&quot;;
import fetchDataFromScript from &quot;../utils/frame-loader&quot;;
import isRequired from &quot;../utils/isRequired&quot;;
import { validateFileFromURI } from &quot;../utils/hashing&quot;;
import { getHttpUri } from &quot;../utils/uri&quot;;
import { sanitizeMetaEvidence } from &quot;../utils/sanitize&quot;;

import StandardContract from &quot;./StandardContract&quot;;

// Polyfill to support Promise.allSettled with node &lt; 12
Promise.allSettled =
  Promise.allSettled ||
  ((promises) =&gt;
    Promise.all(
      promises.map((p) =&gt;
        p
          .then((v) =&gt; ({
            status: &quot;fulfilled&quot;,
            value: v,
          }))
          .catch((e) =&gt; ({
            status: &quot;rejected&quot;,
            reason: e,
          }))
      )
    ));

/**
 * Provides interaction with standard Arbitrable contracts
 * @example
 * const arbitrable = new Arbitable(web3Provider)
 */
class Arbitrable extends StandardContract {
  /**
   * Load an arbitrable web3 contract instance
   * @param {string} contractAddress - Address of the Arbitrable contract.
   * @returns {object} web3 contract instance
   */
  _loadContractInstance = (contractAddress) =&gt; {
    return new this.web3.eth.Contract(ArbitrableJSONInterface.abi, contractAddress);
  };

  /**
   * Fetch all Evidence submitted to the contract.
   * @param {string} contractAddress - The address of the arbitrable contract.
   * @param {string} arbitratorAddress - The address of the arbitrator contract.
   * @param {number} evidenceGroupID - The index of the evidence group.
   * @param {object} options - Additional paramaters. Includes fromBlock, toBlock, filters, strictHashes, strict
   * @returns {object[]} An array of evidence objects
   */
  getEvidence = async (
    contractAddress = isRequired(&quot;contractAddress&quot;),
    arbitratorAddress = isRequired(&quot;arbitratorAddress&quot;),
    evidenceGroupID = isRequired(&quot;evidenceGroupID&quot;),
    options = {}
  ) =&gt; {
    const strict = options.strict || options.strictHashes;

    const contractInstance = this._loadContractInstance(contractAddress);

    const evidenceLogs = await EventListener.getEventLogs(
      contractInstance,
      &quot;Evidence&quot;,
      options.fromBlock || 0,
      options.toBlock || &quot;latest&quot;,
      {
        _arbitrator: arbitratorAddress,
        _evidenceGroupID: evidenceGroupID.toString(),
        ...options.filters,
      }
    );

    if (evidenceLogs.length === 0) return [];

    return (
      await Promise.allSettled(
        evidenceLogs.map(async (evidenceLog) =&gt; {
          const args = await evidenceLog.returnValues;
          const { uri: evidenceURI, preValidated } = getHttpUri(args._evidence, this.ipfsGateway);

          const { file: evidenceJSON, isValid: evidenceJSONValid } = await validateFileFromURI(evidenceURI, {
            preValidated,
            strict,
            strictHashes: options.strictHashes,
            customHashFn: options.customHashFn,
          });

          let fileValid = false;

          try {
            if (evidenceJSON.fileURI) {
              const { uri: evidenceURI, preValidated } = getHttpUri(evidenceJSON.fileURI, this.ipfsGateway);

              fileValid = (
                await validateFileFromURI(evidenceURI, {
                  preValidated,
                  strict,
                  strictHashes: options.strictHashes,
                  hash: evidenceJSON.fileHash,
                  customHashFn: options.customHashFn,
                })
              ).isValid;
            }
          } catch (err) {
            if (strict) {
              throw new Error(err);
            }

            console.warn(&quot;Invalid evidence file:&quot;, err);
          }

          const submittedAt = (
            await new Promise((resolve, reject) =&gt; {
              this.web3.eth.getBlock(evidenceLog.blockNumber, (error, result) =&gt; {
                if (error) reject(error);

                resolve(result);
              });
            })
          ).timestamp;

          return {
            evidenceJSONValid,
            fileValid,
            evidenceJSON,
            submittedAt,
            submittedBy: args._party,
            blockNumber: evidenceLog.blockNumber,
            transactionHash: evidenceLog.transactionHash,
          };
        })
      )
    ).map((r) =&gt; (r.value ? r.value : r));
  };

  /**
   * Get the MetaEvidence object for a metaEvidenceID. Hashes will be validated.
   * By default MetaEvidence will be returned regardless of the validity of the hashes
   * with an indicator on whether the hash was valid or not. To throw an error instead,
   * use strict = true in options object.
   * NOTE: If more than one MetaEvidence with the same metaEvidenceID is found it will return the 1st one.
   * @param {string} contractAddress - The address of the Arbitrable contract.
   * @param {number} metaEvidenceID - The identifier of the metaEvidence log.
   * @param {object} options - Additional paramaters. Includes fromBlock, toBlock, strictHashes
   * @returns {object} The metaEvidence object
   */
  getMetaEvidence = async (
    contractAddress = isRequired(&quot;contractAddress&quot;),
    metaEvidenceID = isRequired(&quot;metaEvidenceID&quot;),
    options = {}
  ) =&gt; {
    const strict = options.strict || options.strictHashes;
    const contractInstance = this._loadContractInstance(contractAddress);

    const metaEvidenceLogs = await EventListener.getEventLogs(
      contractInstance,
      &quot;MetaEvidence&quot;,
      options.fromBlock || 0,
      options.toBlock || &quot;latest&quot;,
      { _metaEvidenceID: metaEvidenceID.toString(), ...options.filters }
    );

    if (!metaEvidenceLogs[0])
      throw new Error(
        errorConstants.CONTRACT_ERROR(
          `No MetaEvidence log for ${contractAddress} with metaEvidenceID ${metaEvidenceID}`
        )
      );

    const metaEvidenceLog = metaEvidenceLogs[0];
    const args = await metaEvidenceLog.returnValues;

    const { uri: metaEvidenceUri, preValidated } = getHttpUri(args._evidence, this.ipfsGateway);

    const { file: _metaEvidenceJSON, isValid: metaEvidenceJSONValid } = await validateFileFromURI(metaEvidenceUri, {
      preValidated,
      strict,
      strictHashes: options.strictHashes,
      customHashFn: options.customHashFn,
    });

    // we want it to be a dynamic variable so we can edit via script if neccesary
    let metaEvidenceJSON = sanitizeMetaEvidence(_metaEvidenceJSON);

    // make updates to metaEvidence from script
    let scriptValid = false;
    try {
      if (metaEvidenceJSON.dynamicScriptURI) {
        const scriptParameters = options.scriptParameters || {};

        if (scriptParameters.disputeID === &quot;302&quot; || scriptParameters.disputeID === &quot;532&quot;) {
          // Need to update web3 for Firefox. Trusted hack for the short term
          scriptValid = true;
          metaEvidenceJSON = {
            ...metaEvidenceJSON,
            ...{
              rulingOptions: {
                type: &quot;single-select&quot;,
                titles: [&quot;Yes&quot;, &quot;No&quot;],
              },
            },
          };
        } else {
          const { uri: scriptURI, preValidated } = getHttpUri(metaEvidenceJSON.dynamicScriptURI, this.ipfsGateway);

          const script = await validateFileFromURI(scriptURI, {
            preValidated,
            strict,
            strictHashes: options.strictHashes,
            hash: metaEvidenceJSON.dynamicScriptHash,
            customHashFn: options.customHashFn,
          });

          scriptValid = script.isValid;

          const fileParameters = {
            arbitratorChainID: metaEvidenceJSON.arbitratorChainID,
            arbitrableChainID: metaEvidenceJSON.arbitrableChainID,
          };

          if (
            fileParameters.arbitrableChainID !== undefined &amp;&amp;
            scriptParameters.arbitrableChainID !== undefined &amp;&amp;
            Number(fileParameters.arbitrableChainID) !== Number(scriptParameters.arbitrableChainID)
          ) {
            throw new Error(
              `MetaEvidence requires &apos;arbitrableChainID&apos; to be ${fileParameters.arbitrableChainID}, but ${scriptParameters.arbitrableChainID} was given`
            );
          }

          if (
            fileParameters.arbitratorChainID !== undefined &amp;&amp;
            scriptParameters.arbitratorChainID !== undefined &amp;&amp;
            Number(fileParameters.arbitratorChainID) !== Number(scriptParameters.arbitratorChainID)
          ) {
            throw new Error(
              `MetaEvidence requires &apos;arbitratorChainID&apos; to be ${fileParameters.arbitratorChainID}, but ${scriptParameters.arbitratorChainID} was given`
            );
          }

          const injectedParameters = {
            ...fileParameters,
            ...scriptParameters,
          };

          if (injectedParameters.arbitrableChainID === undefined) {
            injectedParameters.arbitrableChainID = injectedParameters.arbitratorChainID;
          }

          const metaEvidenceEdits = await fetchDataFromScript(script.file, injectedParameters);

          metaEvidenceJSON = {
            ...metaEvidenceJSON,
            ...metaEvidenceEdits,
          };
        }
      }
    } catch (err) {
      if (strict) {
        throw new Error(err);
      }

      // if we get an error in the execution the script is invalid
      console.warn(&quot;Invalid MetaEvidence file:&quot;, err);
      scriptValid = false;
    }

    let fileValid = false;
    try {
      // validate file hash
      if (metaEvidenceJSON.fileURI) {
        const { uri: fileURI, preValidated } = getHttpUri(metaEvidenceJSON.fileURI, this.ipfsGateway);
        fileValid = (
          await validateFileFromURI(fileURI, {
            preValidated,
            strict,
            strictHashes: options.strictHashes,
            hash: metaEvidenceJSON.fileHash,
            customHashFn: options.customHashFn,
          })
        ).isValid;
      }
    } catch (err) {
      if (strict) {
        throw new Error(err);
      }

      console.warn(&quot;Invalid fileURI:&quot;, err);
    }

    // validate file hash
    let interfaceValid = false;
    // allow for both so not to break previous versions from standard
    const evidenceDisplayURI = metaEvidenceJSON.evidenceDisplayInterfaceURI;
    try {
      if (evidenceDisplayURI) {
        const { uri: disputeInterfaceURI, preValidated } = getHttpUri(evidenceDisplayURI, this.ipfsGateway);
        if (preValidated) interfaceValid = true;
        else
          interfaceValid = (
            await validateFileFromURI(disputeInterfaceURI, {
              strict,
              strictHashes: options.strictHashes,
              hash: metaEvidenceJSON.evidenceDisplayInterfaceHash,
              customHashFn: options.customHashFn,
            })
          ).isValid;
      }
    } catch (err) {
      if (strict) {
        throw new Error(err);
      }

      console.warn(&quot;Invalid evidenceDisplayURI:&quot;, err);
    }

    return {
      metaEvidenceJSON,
      metaEvidenceJSONValid,
      fileValid,
      interfaceValid,
      scriptValid,
      blockNumber: metaEvidenceLog.blockNumber,
      transactionHash: metaEvidenceLog.transactionHash,
    };
  };

  /**
   * Fetch the ruling for a dispute.
   * @param {string} contractAddress - The address of the arbitrable contract.
   * @param {string} arbitratorAddress - The address of the arbitrator contract.
   * @param {number} disputeID - The index of the dispute.
   * @param {object} options - Optional parameters. Includes fromBlock and toBlock.
   * @returns {number} The number denoting the ruling.
   */
  getRuling = async (
    contractAddress = isRequired(&quot;contractAddress&quot;),
    arbitratorAddress = isRequired(&quot;arbitratorAddress&quot;),
    disputeID = isRequired(&quot;disputeID&quot;),
    options = {}
  ) =&gt; {
    const contractInstance = this._loadContractInstance(contractAddress);

    const rulingLogs = await EventListener.getEventLogs(
      contractInstance,
      &quot;Ruling&quot;,
      options.fromBlock || 0,
      options.toBlock || &quot;latest&quot;,
      {
        _arbitrator: arbitratorAddress,
        _disputeID: disputeID.toString(),
        ...options.filters,
      }
    );

    if (rulingLogs.length === 0)
      throw new Error(
        errorConstants.CONTRACT_ERROR(`There is no ruling for dispute ${disputeID} in arbitrator ${arbitratorAddress}`)
      );
    else if (rulingLogs.length &gt; 1)
      throw new Error(
        errorConstants.CONTRACT_ERROR(
          `There is more than one ruling for dispute ${disputeID} in arbitrator ${arbitratorAddress}`
        )
      );

    const rulingLog = rulingLogs[0];
    const args = await rulingLog.returnValues;

    const ruledAt = (
      await new Promise((resolve, reject) =&gt; {
        this.web3.eth.getBlock(rulingLog.blockNumber, (error, result) =&gt; {
          if (error) reject(error);

          resolve(result);
        });
      })
    ).timestamp;

    return {
      ruling: args._ruling,
      ruledAt,
      blockNumber: rulingLog.blockNumber,
      transactionHash: rulingLog.transactionHash,
    };
  };

  /**
   * Get the event log emitted when a dispute has been created. This event links
   * metaEvidence to a dispute by _metaEvidenceID.
   * @param {string} contractAddress - The address of the contract.
   * @param {string} arbitratorAddress - The address of the arbitrator contract.
   * @param {number} disputeID - The index of the dispute.
   * @param {object} options - Optional parameters. Includes fromBlock and toBlock.
   * @returns {object} The data from the event log
   */
  getDispute = async (
    contractAddress = isRequired(&quot;contractAddress&quot;),
    arbitratorAddress = isRequired(&quot;arbitratorAddress&quot;),
    disputeID = isRequired(&quot;isRequired&quot;),
    options = {}
  ) =&gt; {
    const contractInstance = this._loadContractInstance(contractAddress);

    const disputeLogs = await EventListener.getEventLogs(
      contractInstance,
      &quot;Dispute&quot;,
      options.fromBlock || 0,
      options.toBlock || &quot;latest&quot;,
      {
        _arbitrator: arbitratorAddress,
        _disputeID: disputeID.toString(),
        ...options.filters,
      }
    );

    if (disputeLogs.length === 0)
      throw new Error(
        errorConstants.CONTRACT_ERROR(
          `No Dispute log for ${contractAddress} with arbitrator ${arbitratorAddress} and disputeID ${disputeID}`
        )
      );

    if (disputeLogs.length &gt; 1)
      throw new Error(
        errorConstants.CONTRACT_ERROR(
          `More than one Dispute returned for arbitrator ${arbitratorAddress} and disputeID ${disputeID}`
        )
      );

    const disputeLog = disputeLogs[0];
    const args = await disputeLog.returnValues;
    const createdAt = (
      await new Promise((resolve, reject) =&gt; {
        this.web3.eth.getBlock(disputeLog.blockNumber, (error, result) =&gt; {
          if (error) reject(error);

          resolve(result);
        });
      })
    ).timestamp;

    return {
      metaEvidenceID: args._metaEvidenceID,
      evidenceGroupID: args._evidenceGroupID,
      createdAt,
      blockNumber: disputeLog.blockNumber,
      transactionHash: disputeLog.transactionHash,
    };
  };
}

export default Arbitrable;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
